/**
  * gowiny-uni-router v1.0.15
  * https://gitee.com/gowiny/uni-router
  *
  * (c) 2022-present gowiny
  * @license MIT
  *
  * Date: 2022-12-30T04:57:01Z
  */
var GowinyUniRouter = (function (exports, jsUtils, qs) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var qs__default = /*#__PURE__*/_interopDefaultLegacy(qs);

    const UniLifecycleHooks = {
        INIT: 'onInit',
        LOAD: 'onLoad',
        SHOW: 'onShow',
        READY: 'onReady'
    };

    const StaticContext = {
        navLock: false,
        beforeEachLock: false,
        firstRequestState: 'not',
        firstRequestListeners: [],
        handleFirstRequestResult(success) {
            StaticContext.firstRequestListeners.forEach(item => {
                item.success(success);
            });
            StaticContext.firstRequestListeners = [];
        },
        app: undefined,
        route: undefined,
        toRoute: undefined,
        fromRoute: undefined,
        router: undefined
    };

    function getRouteByPage(page) {
        let path = page.route || "";
        if (!path.startsWith("/")) {
            path = '/' + path;
        }
        const result = {
            fullPath: path,
            path
        };
        return result;
    }
    function warn(router, ...args) {
        const logConf = router.options.debugger;
        if (logConf && (logConf === true || logConf.info)) {
            console.warn(...args);
        }
    }
    function getCurrentPagePath() {
        const page = getCurrentPage();
        return page && page.route ? '/' + page.route : undefined;
    }
    function getCurrentPage() {
        const pages = getCurrentPages();
        return pages.length > 0 ? pages[pages.length - 1] : undefined;
    }
    function getRouteByPath(router, path, query, fullPath) {
        fullPath = fullPath || formatFullPath(path, query);
        const key = path.replace(/^\//, '');
        const routeRule = router.routeMap.pathMap[key];
        let result;
        if (routeRule) {
            result = { ...routeRule, fullPath, path, query: query };
        }
        else {
            result = { fullPath, path, query: query };
        }
        return result;
    }
    function getRouteByUrl(url, router) {
        const index = url.indexOf('?');
        let queryString, path;
        if (index > -1) {
            path = url.substring(0, index);
            queryString = url.substring(index + 1);
        }
        else {
            path = url;
            queryString = '';
        }
        const query = queryString ? qs__default["default"].parse(queryString) : {};
        const key = path.replace(/^\//, '');
        const routeRule = router.routeMap.pathMap[key];
        let result;
        if (routeRule) {
            result = { ...routeRule, fullPath: url, path, query };
        }
        else {
            result = { fullPath: url, path, query };
        }
        return result;
    }
    function formatFullPath(path, query) {
        const queryString = qs__default["default"].stringify(query);
        const fullPath = queryString ? `${path}?${queryString}` : path;
        return fullPath;
    }
    function lockNavjump(to, router, navType, force = false) {
        const toParam = {};
        if (jsUtils.isString(to)) {
            toParam.url = to;
        }
        else {
            const toObj = to;
            let path, query = toObj.query;
            if (toObj.name) {
                const nameMap = router.routeMap.nameMap;
                const route = nameMap[toObj.name];
                path = route.path;
            }
            else {
                path = toObj.path;
                query = toObj.query;
            }
            const fullPath = formatFullPath(path, query);
            const otherParams = { ...toObj };
            delete otherParams.name;
            delete otherParams.path;
            delete otherParams.query;
            Object.assign(toParam, otherParams);
            toParam.url = fullPath;
        }
        toParam.$force = force;
        let result;
        switch (navType) {
            case "push" /* PUSH */:
                result = uni.navigateTo(toParam);
                break;
            case "replace" /* REPLACE */:
                result = uni.redirectTo(toParam);
                break;
            case "pushTab" /* PUSH_TAB */:
                result = uni.switchTab(toParam);
                break;
            case "replaceAll" /* REPLACE_ALL */:
                result = uni.reLaunch(toParam);
                break;
            default:
                throw new Error('路由类型不正确');
        }
        return result;
    }
    function appendPages(routes, pathMap, pages) {
        pages.forEach(item => {
            const tempPath = item.path;
            const path = tempPath.startsWith('/') ? tempPath : '/' + tempPath;
            const route = {
                ...item,
                path
            };
            pathMap[path] = route;
            routes.push(route);
        });
    }
    function parseRoutesFromPages({ pages, subPackages = [] }) {
        const routes = [];
        const pathMap = {};
        appendPages(routes, pathMap, pages);
        subPackages.forEach(item => {
            appendPages(routes, pathMap, item.pages);
        });
        return routes;
    }
    async function callEachHooks(router, hookType, to, from) {
        let hooks = router.lifeCycleHooks[hookType];
        const result = await jsUtils.queueInvoke(hooks, null, [to, from], (res) => {
            if (res === false || jsUtils.isObject(res)) {
                return false;
            }
            else {
                return true;
            }
        });
        return result;
    }
    async function invokeAfterEach(router, to, from) {
        return await callEachHooks(router, "ae" /* AFTER_EACH */, to, from);
    }
    async function invokeBeforeEach(router, to, from) {
        StaticContext.beforeEachLock = true;
        try {
            const hookResult = await callEachHooks(router, "be" /* BEFORE_EACH */, to, from);
            if (hookResult === true || hookResult === undefined || hookResult === null) {
                return true;
            }
            else {
                if (hookResult !== false) {
                    let to;
                    let navType = "push" /* PUSH */;
                    if (jsUtils.isString(hookResult)) {
                        to = { path: hookResult };
                        navType = "push" /* PUSH */;
                    }
                    else if (jsUtils.isObject(hookResult)) {
                        const navTarget = hookResult;
                        to = navTarget.to;
                        navType = navTarget.navType;
                    }
                    if (to) {
                        lockNavjump(to, router, navType, true);
                    }
                }
                return false;
            }
        }
        finally {
            StaticContext.beforeEachLock = false;
        }
    }

    let IS_WAPPED = false;
    const METHOD_NAME_NAVIGATE_TO = 'navigateTo';
    const METHOD_NAME_REDIRECT_TO = 'redirectTo';
    const METHOD_NAME_RELAUNCH = 'reLaunch';
    const METHOD_NAME_SWITCH_TAB = 'switchTab';
    const METHOD_NAME_NAVIGATE_BACK = 'navigateBack';
    const oldMethods = {
        [METHOD_NAME_NAVIGATE_TO]: uni.navigateTo,
        [METHOD_NAME_REDIRECT_TO]: uni.redirectTo,
        [METHOD_NAME_RELAUNCH]: uni.reLaunch,
        [METHOD_NAME_SWITCH_TAB]: uni.switchTab,
        [METHOD_NAME_NAVIGATE_BACK]: uni.navigateBack,
    };
    function callOldMethod(methodName, options) {
        const method = oldMethods[methodName];
        if (method) {
            method(options);
        }
    }
    function callNavError(unlock, options, err) {
        if (options.fail) {
            options.fail(err);
        }
        if (options.complete) {
            options.complete();
        }
        if (unlock) {
            StaticContext.navLock = false;
        }
    }
    function callNavSuccess(methodName, options) {
        const newArgs = {
            ...options,
            async success(...args) {
                try {
                    options.success && await options.success(...args);
                }
                finally {
                    StaticContext.route = StaticContext.toRoute;
                    StaticContext.lastFullPath = StaticContext.route ? StaticContext.route.fullPath : undefined;
                    if (StaticContext.router &&
                        StaticContext.toRoute) {
                        StaticContext.router.route = StaticContext.route;
                        await invokeAfterEach(StaticContext.router, StaticContext.toRoute, StaticContext.fromRoute);
                    }
                    StaticContext.navLock = false;
                }
            },
            async fail(...args) {
                try {
                    console.error(args && args[0] ? args[0].errMsg : '');
                    options.fail && await options.fail(...args);
                }
                finally {
                    StaticContext.navLock = false;
                }
            },
            complete(...args) {
                options.complete && options.complete(...args);
            }
        };
        callOldMethod(methodName, newArgs);
    }
    function createWapper(methodName) {
        async function wapper(options) {
            if ((StaticContext.navLock || StaticContext.beforeEachLock) && !options.$force) {
                StaticContext.router && warn(StaticContext.router, '当前页面正在处于跳转状态，请稍后再进行跳转....');
                return callNavError(false, options, '当前页面正在处于跳转状态，请稍后再进行跳转....');
            }
            StaticContext.navLock = true;
            try {
                if (!StaticContext.router) {
                    return callNavSuccess(methodName, options);
                }
                const router = StaticContext.router;
                let to;
                if (METHOD_NAME_NAVIGATE_BACK == methodName) {
                    const delta = jsUtils.isNumber(options.delta) ? options.delta : 1;
                    const pages = getCurrentPages();
                    const pageIndex = pages.length - delta - 1;
                    if (pageIndex < 0) {
                        to = getRouteByUrl(router.indexRouteRule.path, router);
                    }
                    else {
                        to = getRouteByPage(pages[pageIndex]);
                    }
                }
                else {
                    const url = options.url;
                    to = getRouteByUrl(url, router);
                }
                const from = StaticContext.route;
                StaticContext.toRoute = to;
                StaticContext.fromRoute = from;
                StaticContext.destFullPath = to.fullPath;
                const hookResult = await invokeBeforeEach(router, to, from);
                if (!hookResult) {
                    return callNavError(true, options, '路由守卫拦截');
                }
                return callNavSuccess(methodName, options);
            }
            catch (err) {
                return callNavError(true, options, err);
            }
        }
        return wapper;
    }
    function addNavInterceptor() {
        if (IS_WAPPED) {
            return;
        }
        IS_WAPPED = true;
        uni.navigateTo = createWapper(METHOD_NAME_NAVIGATE_TO);
        uni.redirectTo = createWapper(METHOD_NAME_REDIRECT_TO);
        uni.reLaunch = createWapper(METHOD_NAME_RELAUNCH);
        uni.switchTab = createWapper(METHOD_NAME_SWITCH_TAB);
        uni.navigateBack = createWapper(METHOD_NAME_NAVIGATE_BACK);
    }

    const DEFAULT_PROXY_METHODS = [UniLifecycleHooks.INIT, UniLifecycleHooks.LOAD, UniLifecycleHooks.SHOW, UniLifecycleHooks.READY];
    const MP_TYPE_PAGE = 'page';
    function getRouterData(vm) {
        if (!vm.__routerData) {
            vm.__routerData = {};
        }
        return vm.__routerData;
    }
    function getOriHookDataMap(vm) {
        const routerData = getRouterData(vm);
        if (!routerData.oriHookDataMap) {
            routerData.oriHookDataMap = {};
        }
        return routerData.oriHookDataMap;
    }
    function getOriHookData(vm, hookType) {
        const dataMap = getOriHookDataMap(vm);
        let data = dataMap[hookType];
        if (!data) {
            data = {
                oldVal: []
            };
            dataMap[hookType] = data;
        }
        return data;
    }
    function invokeOriMethod(methodName, vm, args) {
        const routerData = getRouterData(vm);
        const oldMethods = routerData.oldMethods || {};
        const method = oldMethods[methodName];
        if (method) {
            return method.apply(vm, args);
        }
    }
    function invokeOriHooks(hookType, target, args) {
        const oriHookData = getOriHookData(target, hookType);
        jsUtils.invoke(oriHookData.oldVal, target, args);
    }
    function saveOriRoute(vm, oriRoute) {
        const routerData = getRouterData(vm);
        routerData.oriRoute = oriRoute;
    }
    function getOriRoute(vm) {
        const routerData = getRouterData(vm);
        if (!routerData.oriRoute) {
            routerData.oriRoute = {};
        }
        return routerData.oriRoute;
    }
    function saveCurrRouteByCurrPage(router, vm, query = {}) {
        const page = getCurrentPage();
        if (!page || !page.route) {
            return;
        }
        const path = '/' + page.route;
        saveOriRoute(vm, {
            path,
            query
        });
        const currRoute = getRouteByPath(router, path, query);
        router.route = currRoute;
    }
    function wapperMethod(router, vm, methodName, args) {
        return wapperFun(router, "method" /* METHOD */, vm, methodName, args, invokeOriMethod);
    }
    async function wapperFun(router, proxyMode, vm, methodName, args, successCallback) {
        const routerData = getRouterData(vm);
        const lock = routerData.hookLock || false;
        if (lock === true) {
            //console.log(`wapperFun 已被锁，等待解锁后执行,${methodName}`,vm)
            if (!routerData.hookListeners) {
                routerData.hookListeners = [];
            }
            const asyncFun = new Promise((success, fail) => {
                routerData.hookListeners.push({ success, fail });
            });
            const asyncResult = await asyncFun;
            let result;
            if (asyncResult) {
                //console.log(`wapperFun 已解锁，现在执行,${methodName}`,vm)
                result = successCallback(methodName, vm, args);
            }
            return result;
        }
        routerData.hookLock = true;
        //console.log(`wapperFun 加锁,${methodName}`,vm)
        let result;
        try {
            const path = getCurrentPagePath();
            let query;
            if (proxyMode === "hook" /* HOOK */ && (UniLifecycleHooks.INIT == methodName || UniLifecycleHooks.LOAD == methodName)) {
                query = args[0] || {};
                const queryKeys = Object.keys(query);
                queryKeys.forEach(key => {
                    const val = query[key];
                    if (val) {
                        query[key] = decodeURIComponent(val);
                    }
                });
                saveOriRoute(vm, {
                    path, query
                });
            }
            else {
                query = getOriRoute(vm).query || {};
            }
            let isOk = true;
            if (path) {
                const fullPath = formatFullPath(path, query);
                if (StaticContext.destFullPath != fullPath) {
                    //console.log(`当前路径跟最后路由路径不一致，需要执行守卫,${methodName}`,fullPath,StaticContext.lastFullPath)
                    const to = getRouteByPath(router, path, query, fullPath);
                    const from = StaticContext.route;
                    StaticContext.toRoute = to;
                    StaticContext.fromRoute = from;
                    isOk = await invokeBeforeEach(router, to, from);
                    if (isOk) {
                        StaticContext.route = to;
                        router.route = to;
                        StaticContext.lastFullPath = fullPath;
                        await invokeAfterEach(router, to, from);
                    }
                }
                else {
                    //console.log(`当前路径跟最后路由路径一致，直接执行后续动作,${methodName}`,fullPath)
                }
            }
            if (isOk) {
                result = successCallback(methodName, vm, args);
            }
            if (routerData.hookListeners) {
                const hookListeners = routerData.hookListeners;
                for (let i = 0; i < hookListeners.length; i++) {
                    const item = hookListeners[i];
                    item.success(isOk);
                }
                routerData.hookListeners = [];
            }
        }
        catch (err) {
            if (routerData.hookListeners) {
                const hookListeners = routerData.hookListeners;
                for (let i = 0; i < hookListeners.length; i++) {
                    const item = hookListeners[i];
                    item.fail(err);
                }
                routerData.hookListeners = [];
            }
        }
        routerData.hookLock = false;
        return result;
    }
    function wapperHook(router, vm, hookType, args) {
        return wapperFun(router, "hook" /* HOOK */, vm, hookType, args, invokeOriHooks);
    }
    function wapperUniHooks(router, vm, hookType) {
        function result(...args) {
            wapperHook(router, vm, hookType, args);
        }
        return result;
    }
    function appendRoutes(router, routeMap, root = '', routes) {
        if (!routes || routes.length == 0) {
            return;
        }
        const pathMap = routeMap.pathMap;
        const nameMap = routeMap.nameMap;
        routes.forEach(route => {
            const { alias, path, name } = route;
            if (path == null) {
                throw new Error(`请提供一个完整的路由对象，包括以绝对路径开始的 ‘path’ 字符串 ${JSON.stringify(route)}`);
            }
            const fullPath = root + path;
            pathMap[fullPath] = route;
            if (name) {
                nameMap[name] = route;
            }
            if (alias) {
                if (Array.isArray(alias)) {
                    alias.forEach(item => {
                        const fullPath = root + item;
                        pathMap[fullPath] = route;
                    });
                }
                else {
                    const fullPath = root + alias;
                    pathMap[fullPath] = route;
                }
            }
            appendRoutes(router, routeMap, route.path, route.children);
        });
    }
    function createRouteMap(router, routes) {
        const pathMap = Object.create(null);
        const nameMap = Object.create(null);
        const routeMap = {
            pathMap: pathMap,
            nameMap: nameMap
        };
        appendRoutes(router, routeMap, '', routes);
        return routeMap;
    }
    function registerEachHooks(router, hookType, userGuard) {
        let hooks = router.lifeCycleHooks[hookType];
        if (!hooks) {
            hooks = [];
            router.lifeCycleHooks[hookType] = hooks;
        }
        hooks.push(userGuard);
    }
    function isPageHook(vm) {
        return vm.$mpType === MP_TYPE_PAGE;
    }
    class RouterImpl {
        proxyMode;
        proxyMethods;
        routes;
        indexRouteRule;
        lifeCycleHooks = {};
        $locked = false;
        options;
        routeMap;
        route;
        constructor(options) {
            this.options = options;
            this.proxyMode = options.proxyMode || "hook" /* HOOK */;
            this.proxyMethods = options.proxyMethods || DEFAULT_PROXY_METHODS;
            this.routes = parseRoutesFromPages(options.pageData);
            this.indexRouteRule = this.routes[0];
            this.routeMap = createRouteMap(this, this.routes);
        }
        setupRouter(app) {
            app.use(this);
        }
        push(to) {
            return lockNavjump(to, this, "push" /* PUSH */);
        }
        replace(to) {
            return lockNavjump(to, this, "replace" /* REPLACE */);
        }
        replaceAll(to) {
            return lockNavjump(to, this, "replaceAll" /* REPLACE_ALL */);
        }
        pushTab(to) {
            return lockNavjump(to, this, "pushTab" /* PUSH_TAB */);
        }
        back(...args) {
            return uni.navigateBack(...args);
        }
        beforeEach(userGuard) {
            registerEachHooks(this, "be" /* BEFORE_EACH */, userGuard);
        }
        afterEach(userGuard) {
            registerEachHooks(this, "ae" /* AFTER_EACH */, userGuard);
        }
        async install(app, ...options) {
            const router = this;
            StaticContext.app = app;
            StaticContext.router = router;
            Object.defineProperty(app.config.globalProperties, "$Router", {
                get() {
                    return router;
                }
            });
            Object.defineProperty(app.config.globalProperties, "$Route", {
                get() {
                    return router.route;
                }
            });
            let mixinOptions;
            if (router.proxyMode === "hook" /* HOOK */) {
                mixinOptions = {
                    beforeCreate() {
                        if (!isPageHook(this)) {
                            return;
                        }
                        const vm = this;
                        router.proxyMethods.forEach(hookName => {
                            const oriHookData = getOriHookData(vm, hookName);
                            const oldHooks = vm.$[hookName] || [];
                            const oldVal = Array.isArray(oldHooks) ? oldHooks : [oldHooks];
                            oriHookData.oldVal = oldVal;
                            oriHookData.wapper = wapperUniHooks(router, vm, hookName);
                            const newVal = [oriHookData.wapper];
                            const newValObj = newVal;
                            newVal.push = function (...args) {
                                oriHookData.oldVal.push(...args);
                                return newVal.length;
                            };
                            newVal.pop = function () {
                                return oriHookData.oldVal.pop();
                            };
                            newVal.shift = function () {
                                return oriHookData.oldVal.shift();
                            };
                            newVal.unshift = function (...args) {
                                oriHookData.oldVal.unshift(...args);
                                return newVal.length;
                            };
                            newValObj.splice = function (...args) {
                                return oriHookData.oldVal.splice(...args);
                            };
                            newVal.reverse = function () {
                                return oriHookData.oldVal.reverse();
                            };
                            newVal.sort = function () {
                                return oriHookData.oldVal.sort();
                            };
                            oriHookData.newVal = newVal;
                            Object.defineProperty(vm.$, hookName, {
                                get() {
                                    return oriHookData.newVal;
                                },
                                set(val) {
                                    if (val === oriHookData.newVal || val === oriHookData.wapper) {
                                        return;
                                    }
                                    if (!val) {
                                        oriHookData.oldVal = [];
                                    }
                                    else if (Array.isArray(val)) {
                                        if (val.indexOf(oriHookData.wapper) > -1) {
                                            if (val.length > 1) {
                                                val.forEach(item => {
                                                    if (item !== oriHookData.wapper) {
                                                        oriHookData.oldVal.push(item);
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            oriHookData.oldVal = val;
                                        }
                                    }
                                    else {
                                        oriHookData.oldVal = [val];
                                    }
                                }
                            });
                        });
                    }
                };
            }
            else if (router.proxyMode === "method" /* METHOD */) {
                mixinOptions = {
                    created() {
                        if (!isPageHook(this)) {
                            return;
                        }
                        const vm = this;
                        const routerData = getRouterData(vm);
                        const oldMethods = {};
                        routerData.oldMethods = oldMethods;
                        router.proxyMethods.forEach(methodName => {
                            const oldMethod = vm[methodName];
                            if (!oldMethod) {
                                console.warn(`此页面没有方法:${methodName}`);
                                return;
                            }
                            oldMethods[methodName] = oldMethod;
                            //console.warn(`设置代理:${methodName}`)
                            vm[methodName] = (...args) => {
                                //console.warn(`执行代理:${methodName}`)
                                return wapperMethod(router, vm, methodName, args);
                            };
                        });
                    },
                    onInit(query) {
                        if (!isPageHook(this)) {
                            return;
                        }
                        saveCurrRouteByCurrPage(router, this, query);
                    },
                    onLoad(query) {
                        if (!isPageHook(this)) {
                            return;
                        }
                        saveCurrRouteByCurrPage(router, this, query);
                    }
                };
            }
            mixinOptions && app.mixin(mixinOptions);
            addNavInterceptor();
        }
    }
    function createRouter(options) {
        const router = new RouterImpl(options);
        return router;
    }

    exports.UniLifecycleHooks = UniLifecycleHooks;
    exports.createRouter = createRouter;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({}, GowinyUtils, qs);
