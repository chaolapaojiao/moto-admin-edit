import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

var _oldMethods;

import _regeneratorRuntime from "@babel/runtime/regenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
  * gowiny-uni-router v1.0.15
  * https://gitee.com/gowiny/uni-router
  *
  * (c) 2022-present gowiny
  * @license MIT
  *
  * Date: 2022-12-30T04:57:01Z
  */
import { isString, isObject, queueInvoke, isNumber, invoke } from '@gowiny/js-utils';
import qs from 'qs';
var UniLifecycleHooks = {
  INIT: 'onInit',
  LOAD: 'onLoad',
  SHOW: 'onShow',
  READY: 'onReady'
};
var StaticContext = {
  navLock: false,
  beforeEachLock: false,
  firstRequestState: 'not',
  firstRequestListeners: [],
  handleFirstRequestResult: function handleFirstRequestResult(success) {
    StaticContext.firstRequestListeners.forEach(function (item) {
      item.success(success);
    });
    StaticContext.firstRequestListeners = [];
  },
  app: undefined,
  route: undefined,
  toRoute: undefined,
  fromRoute: undefined,
  router: undefined
};

function getRouteByPage(page) {
  var path = page.route || "";

  if (!path.startsWith("/")) {
    path = '/' + path;
  }

  var result = {
    fullPath: path,
    path: path
  };
  return result;
}

function warn(router) {
  var logConf = router.options["debugger"];

  if (logConf && (logConf === true || logConf.info)) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).warn.apply(_console, args);
  }
}

function getCurrentPagePath() {
  var page = getCurrentPage();
  return page && page.route ? '/' + page.route : undefined;
}

function getCurrentPage() {
  var pages = getCurrentPages();
  return pages.length > 0 ? pages[pages.length - 1] : undefined;
}

function getRouteByPath(router, path, query, fullPath) {
  fullPath = fullPath || formatFullPath(path, query);
  var key = path.replace(/^\//, '');
  var routeRule = router.routeMap.pathMap[key];
  var result;

  if (routeRule) {
    result = _objectSpread(_objectSpread({}, routeRule), {}, {
      fullPath: fullPath,
      path: path,
      query: query
    });
  } else {
    result = {
      fullPath: fullPath,
      path: path,
      query: query
    };
  }

  return result;
}

function getRouteByUrl(url, router) {
  var index = url.indexOf('?');
  var queryString, path;

  if (index > -1) {
    path = url.substring(0, index);
    queryString = url.substring(index + 1);
  } else {
    path = url;
    queryString = '';
  }

  var query = queryString ? qs.parse(queryString) : {};
  var key = path.replace(/^\//, '');
  var routeRule = router.routeMap.pathMap[key];
  var result;

  if (routeRule) {
    result = _objectSpread(_objectSpread({}, routeRule), {}, {
      fullPath: url,
      path: path,
      query: query
    });
  } else {
    result = {
      fullPath: url,
      path: path,
      query: query
    };
  }

  return result;
}

function formatFullPath(path, query) {
  var queryString = qs.stringify(query);
  var fullPath = queryString ? "".concat(path, "?").concat(queryString) : path;
  return fullPath;
}

function lockNavjump(to, router, navType) {
  var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var toParam = {};

  if (isString(to)) {
    toParam.url = to;
  } else {
    var toObj = to;
    var path,
        query = toObj.query;

    if (toObj.name) {
      var nameMap = router.routeMap.nameMap;
      var route = nameMap[toObj.name];
      path = route.path;
    } else {
      path = toObj.path;
      query = toObj.query;
    }

    var fullPath = formatFullPath(path, query);

    var otherParams = _objectSpread({}, toObj);

    delete otherParams.name;
    delete otherParams.path;
    delete otherParams.query;
    Object.assign(toParam, otherParams);
    toParam.url = fullPath;
  }

  toParam.$force = force;
  var result;

  switch (navType) {
    case "push"
    /* PUSH */
    :
      result = uni.navigateTo(toParam);
      break;

    case "replace"
    /* REPLACE */
    :
      result = uni.redirectTo(toParam);
      break;

    case "pushTab"
    /* PUSH_TAB */
    :
      result = uni.switchTab(toParam);
      break;

    case "replaceAll"
    /* REPLACE_ALL */
    :
      result = uni.reLaunch(toParam);
      break;

    default:
      throw new Error('路由类型不正确');
  }

  return result;
}

function appendPages(routes, pathMap, pages) {
  pages.forEach(function (item) {
    var tempPath = item.path;
    var path = tempPath.startsWith('/') ? tempPath : '/' + tempPath;

    var route = _objectSpread(_objectSpread({}, item), {}, {
      path: path
    });

    pathMap[path] = route;
    routes.push(route);
  });
}

function parseRoutesFromPages(_ref) {
  var pages = _ref.pages,
      _ref$subPackages = _ref.subPackages,
      subPackages = _ref$subPackages === void 0 ? [] : _ref$subPackages;
  var routes = [];
  var pathMap = {};
  appendPages(routes, pathMap, pages);
  subPackages.forEach(function (item) {
    appendPages(routes, pathMap, item.pages);
  });
  return routes;
}

function callEachHooks(_x, _x2, _x3, _x4) {
  return _callEachHooks.apply(this, arguments);
}

function _callEachHooks() {
  _callEachHooks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(router, hookType, to, from) {
    var hooks, result;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            hooks = router.lifeCycleHooks[hookType];
            _context5.next = 3;
            return queueInvoke(hooks, null, [to, from], function (res) {
              if (res === false || isObject(res)) {
                return false;
              } else {
                return true;
              }
            });

          case 3:
            result = _context5.sent;
            return _context5.abrupt("return", result);

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _callEachHooks.apply(this, arguments);
}

function invokeAfterEach(_x5, _x6, _x7) {
  return _invokeAfterEach.apply(this, arguments);
}

function _invokeAfterEach() {
  _invokeAfterEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(router, to, from) {
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return callEachHooks(router, "ae"
            /* AFTER_EACH */
            , to, from);

          case 2:
            return _context6.abrupt("return", _context6.sent);

          case 3:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _invokeAfterEach.apply(this, arguments);
}

function invokeBeforeEach(_x8, _x9, _x10) {
  return _invokeBeforeEach.apply(this, arguments);
}

function _invokeBeforeEach() {
  _invokeBeforeEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(router, to, from) {
    var hookResult, _to, navType, navTarget;

    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            StaticContext.beforeEachLock = true;
            _context7.prev = 1;
            _context7.next = 4;
            return callEachHooks(router, "be"
            /* BEFORE_EACH */
            , to, from);

          case 4:
            hookResult = _context7.sent;

            if (!(hookResult === true || hookResult === undefined || hookResult === null)) {
              _context7.next = 9;
              break;
            }

            return _context7.abrupt("return", true);

          case 9:
            if (hookResult !== false) {
              navType = "push";

              if (isString(hookResult)) {
                _to = {
                  path: hookResult
                };
                navType = "push"
                /* PUSH */
                ;
              } else if (isObject(hookResult)) {
                navTarget = hookResult;
                _to = navTarget.to;
                navType = navTarget.navType;
              }

              if (_to) {
                lockNavjump(_to, router, navType, true);
              }
            }

            return _context7.abrupt("return", false);

          case 11:
            _context7.prev = 11;
            StaticContext.beforeEachLock = false;
            return _context7.finish(11);

          case 14:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[1,, 11, 14]]);
  }));
  return _invokeBeforeEach.apply(this, arguments);
}

var IS_WAPPED = false;
var METHOD_NAME_NAVIGATE_TO = 'navigateTo';
var METHOD_NAME_REDIRECT_TO = 'redirectTo';
var METHOD_NAME_RELAUNCH = 'reLaunch';
var METHOD_NAME_SWITCH_TAB = 'switchTab';
var METHOD_NAME_NAVIGATE_BACK = 'navigateBack';
var oldMethods = (_oldMethods = {}, _defineProperty(_oldMethods, METHOD_NAME_NAVIGATE_TO, uni.navigateTo), _defineProperty(_oldMethods, METHOD_NAME_REDIRECT_TO, uni.redirectTo), _defineProperty(_oldMethods, METHOD_NAME_RELAUNCH, uni.reLaunch), _defineProperty(_oldMethods, METHOD_NAME_SWITCH_TAB, uni.switchTab), _defineProperty(_oldMethods, METHOD_NAME_NAVIGATE_BACK, uni.navigateBack), _oldMethods);

function callOldMethod(methodName, options) {
  var method = oldMethods[methodName];

  if (method) {
    method(options);
  }
}

function callNavError(unlock, options, err) {
  if (options.fail) {
    options.fail(err);
  }

  if (options.complete) {
    options.complete();
  }

  if (unlock) {
    StaticContext.navLock = false;
  }
}

function callNavSuccess(methodName, options) {
  var newArgs = _objectSpread(_objectSpread({}, options), {}, {
    success: function success() {
      var _arguments = arguments;
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.t0 = options.success;

                if (!_context.t0) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return options.success.apply(options, _toConsumableArray(_arguments));

              case 5:
                _context.prev = 5;
                StaticContext.route = StaticContext.toRoute;
                StaticContext.lastFullPath = StaticContext.route ? StaticContext.route.fullPath : undefined;

                if (!(StaticContext.router && StaticContext.toRoute)) {
                  _context.next = 12;
                  break;
                }

                StaticContext.router.route = StaticContext.route;
                _context.next = 12;
                return invokeAfterEach(StaticContext.router, StaticContext.toRoute, StaticContext.fromRoute);

              case 12:
                StaticContext.navLock = false;
                return _context.finish(5);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0,, 5, 14]]);
      }))();
    },
    fail: function fail() {
      var _arguments2 = arguments;
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _len2, args, _key2;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;

                for (_len2 = _arguments2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = _arguments2[_key2];
                }

                console.error(args && args[0] ? args[0].errMsg : '');
                _context2.t0 = options.fail;

                if (!_context2.t0) {
                  _context2.next = 7;
                  break;
                }

                _context2.next = 7;
                return options.fail.apply(options, args);

              case 7:
                _context2.prev = 7;
                StaticContext.navLock = false;
                return _context2.finish(7);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0,, 7, 10]]);
      }))();
    },
    complete: function complete() {
      options.complete && options.complete.apply(options, arguments);
    }
  });

  callOldMethod(methodName, newArgs);
}

function createWapper(methodName) {
  function wapper(_x11) {
    return _wapper.apply(this, arguments);
  }

  function _wapper() {
    _wapper = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {
      var router, to, delta, pages, pageIndex, url, from, hookResult;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!((StaticContext.navLock || StaticContext.beforeEachLock) && !options.$force)) {
                _context3.next = 3;
                break;
              }

              StaticContext.router && warn(StaticContext.router, '当前页面正在处于跳转状态，请稍后再进行跳转....');
              return _context3.abrupt("return", callNavError(false, options, '当前页面正在处于跳转状态，请稍后再进行跳转....'));

            case 3:
              StaticContext.navLock = true;
              _context3.prev = 4;

              if (StaticContext.router) {
                _context3.next = 7;
                break;
              }

              return _context3.abrupt("return", callNavSuccess(methodName, options));

            case 7:
              router = StaticContext.router;

              if (METHOD_NAME_NAVIGATE_BACK == methodName) {
                delta = isNumber(options.delta) ? options.delta : 1;
                pages = getCurrentPages();
                pageIndex = pages.length - delta - 1;

                if (pageIndex < 0) {
                  to = getRouteByUrl(router.indexRouteRule.path, router);
                } else {
                  to = getRouteByPage(pages[pageIndex]);
                }
              } else {
                url = options.url;
                to = getRouteByUrl(url, router);
              }

              from = StaticContext.route;
              StaticContext.toRoute = to;
              StaticContext.fromRoute = from;
              StaticContext.destFullPath = to.fullPath;
              _context3.next = 15;
              return invokeBeforeEach(router, to, from);

            case 15:
              hookResult = _context3.sent;

              if (hookResult) {
                _context3.next = 18;
                break;
              }

              return _context3.abrupt("return", callNavError(true, options, '路由守卫拦截'));

            case 18:
              return _context3.abrupt("return", callNavSuccess(methodName, options));

            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](4);
              return _context3.abrupt("return", callNavError(true, options, _context3.t0));

            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[4, 21]]);
    }));
    return _wapper.apply(this, arguments);
  }

  return wapper;
}

function addNavInterceptor() {
  if (IS_WAPPED) {
    return;
  }

  IS_WAPPED = true;
  uni.navigateTo = createWapper(METHOD_NAME_NAVIGATE_TO);
  uni.redirectTo = createWapper(METHOD_NAME_REDIRECT_TO);
  uni.reLaunch = createWapper(METHOD_NAME_RELAUNCH);
  uni.switchTab = createWapper(METHOD_NAME_SWITCH_TAB);
  uni.navigateBack = createWapper(METHOD_NAME_NAVIGATE_BACK);
}

var DEFAULT_PROXY_METHODS = [UniLifecycleHooks.INIT, UniLifecycleHooks.LOAD, UniLifecycleHooks.SHOW, UniLifecycleHooks.READY];
var MP_TYPE_PAGE = 'page';

function getRouterData(vm) {
  if (!vm.__routerData) {
    vm.__routerData = {};
  }

  return vm.__routerData;
}

function getOriHookDataMap(vm) {
  var routerData = getRouterData(vm);

  if (!routerData.oriHookDataMap) {
    routerData.oriHookDataMap = {};
  }

  return routerData.oriHookDataMap;
}

function getOriHookData(vm, hookType) {
  var dataMap = getOriHookDataMap(vm);
  var data = dataMap[hookType];

  if (!data) {
    data = {
      oldVal: []
    };
    dataMap[hookType] = data;
  }

  return data;
}

function invokeOriMethod(methodName, vm, args) {
  var routerData = getRouterData(vm);
  var oldMethods = routerData.oldMethods || {};
  var method = oldMethods[methodName];

  if (method) {
    return method.apply(vm, args);
  }
}

function invokeOriHooks(hookType, target, args) {
  var oriHookData = getOriHookData(target, hookType);
  invoke(oriHookData.oldVal, target, args);
}

function saveOriRoute(vm, oriRoute) {
  var routerData = getRouterData(vm);
  routerData.oriRoute = oriRoute;
}

function getOriRoute(vm) {
  var routerData = getRouterData(vm);

  if (!routerData.oriRoute) {
    routerData.oriRoute = {};
  }

  return routerData.oriRoute;
}

function saveCurrRouteByCurrPage(router, vm) {
  var query = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var page = getCurrentPage();

  if (!page || !page.route) {
    return;
  }

  var path = '/' + page.route;
  saveOriRoute(vm, {
    path: path,
    query: query
  });
  var currRoute = getRouteByPath(router, path, query);
  router.route = currRoute;
}

function wapperMethod(router, vm, methodName, args) {
  return wapperFun(router, "method"
  /* METHOD */
  , vm, methodName, args, invokeOriMethod);
}

function wapperFun(_x12, _x13, _x14, _x15, _x16, _x17) {
  return _wapperFun.apply(this, arguments);
}

function _wapperFun() {
  _wapperFun = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(router, proxyMode, vm, methodName, args, successCallback) {
    var routerData, lock, asyncFun, asyncResult, _result, result, path, query, queryKeys, isOk, fullPath, to, from, hookListeners, i, item, _hookListeners, _i, _item;

    return _regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            routerData = getRouterData(vm);
            lock = routerData.hookLock || false;

            if (!(lock === true)) {
              _context8.next = 10;
              break;
            }

            //console.log(`wapperFun 已被锁，等待解锁后执行,${methodName}`,vm)
            if (!routerData.hookListeners) {
              routerData.hookListeners = [];
            }

            asyncFun = new Promise(function (success, fail) {
              routerData.hookListeners.push({
                success: success,
                fail: fail
              });
            });
            _context8.next = 7;
            return asyncFun;

          case 7:
            asyncResult = _context8.sent;

            if (asyncResult) {
              //console.log(`wapperFun 已解锁，现在执行,${methodName}`,vm)
              _result = successCallback(methodName, vm, args);
            }

            return _context8.abrupt("return", _result);

          case 10:
            routerData.hookLock = true; //console.log(`wapperFun 加锁,${methodName}`,vm)

            _context8.prev = 11;
            path = getCurrentPagePath();

            if (proxyMode === "hook"
            /* HOOK */
            && (UniLifecycleHooks.INIT == methodName || UniLifecycleHooks.LOAD == methodName)) {
              query = args[0] || {};
              queryKeys = Object.keys(query);
              queryKeys.forEach(function (key) {
                var val = query[key];

                if (val) {
                  query[key] = decodeURIComponent(val);
                }
              });
              saveOriRoute(vm, {
                path: path,
                query: query
              });
            } else {
              query = getOriRoute(vm).query || {};
            }

            isOk = true;

            if (!path) {
              _context8.next = 33;
              break;
            }

            fullPath = formatFullPath(path, query);

            if (!(StaticContext.destFullPath != fullPath)) {
              _context8.next = 33;
              break;
            }

            //console.log(`当前路径跟最后路由路径不一致，需要执行守卫,${methodName}`,fullPath,StaticContext.lastFullPath)
            to = getRouteByPath(router, path, query, fullPath);
            from = StaticContext.route;
            StaticContext.toRoute = to;
            StaticContext.fromRoute = from;
            _context8.next = 24;
            return invokeBeforeEach(router, to, from);

          case 24:
            isOk = _context8.sent;

            if (!isOk) {
              _context8.next = 31;
              break;
            }

            StaticContext.route = to;
            router.route = to;
            StaticContext.lastFullPath = fullPath;
            _context8.next = 31;
            return invokeAfterEach(router, to, from);

          case 31:
            _context8.next = 33;
            break;

          case 33:
            if (isOk) {
              result = successCallback(methodName, vm, args);
            }

            if (routerData.hookListeners) {
              hookListeners = routerData.hookListeners;

              for (i = 0; i < hookListeners.length; i++) {
                item = hookListeners[i];
                item.success(isOk);
              }

              routerData.hookListeners = [];
            }

            _context8.next = 40;
            break;

          case 37:
            _context8.prev = 37;
            _context8.t0 = _context8["catch"](11);

            if (routerData.hookListeners) {
              _hookListeners = routerData.hookListeners;

              for (_i = 0; _i < _hookListeners.length; _i++) {
                _item = _hookListeners[_i];

                _item.fail(_context8.t0);
              }

              routerData.hookListeners = [];
            }

          case 40:
            routerData.hookLock = false;
            return _context8.abrupt("return", result);

          case 42:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, null, [[11, 37]]);
  }));
  return _wapperFun.apply(this, arguments);
}

function wapperHook(router, vm, hookType, args) {
  return wapperFun(router, "hook"
  /* HOOK */
  , vm, hookType, args, invokeOriHooks);
}

function wapperUniHooks(router, vm, hookType) {
  function result() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    wapperHook(router, vm, hookType, args);
  }

  return result;
}

function appendRoutes(router, routeMap) {
  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var routes = arguments.length > 3 ? arguments[3] : undefined;

  if (!routes || routes.length == 0) {
    return;
  }

  var pathMap = routeMap.pathMap;
  var nameMap = routeMap.nameMap;
  routes.forEach(function (route) {
    var alias = route.alias,
        path = route.path,
        name = route.name;

    if (path == null) {
      throw new Error("\u8BF7\u63D0\u4F9B\u4E00\u4E2A\u5B8C\u6574\u7684\u8DEF\u7531\u5BF9\u8C61\uFF0C\u5305\u62EC\u4EE5\u7EDD\u5BF9\u8DEF\u5F84\u5F00\u59CB\u7684 \u2018path\u2019 \u5B57\u7B26\u4E32 ".concat(JSON.stringify(route)));
    }

    var fullPath = root + path;
    pathMap[fullPath] = route;

    if (name) {
      nameMap[name] = route;
    }

    if (alias) {
      if (Array.isArray(alias)) {
        alias.forEach(function (item) {
          var fullPath = root + item;
          pathMap[fullPath] = route;
        });
      } else {
        var _fullPath = root + alias;

        pathMap[_fullPath] = route;
      }
    }

    appendRoutes(router, routeMap, route.path, route.children);
  });
}

function createRouteMap(router, routes) {
  var pathMap = Object.create(null);
  var nameMap = Object.create(null);
  var routeMap = {
    pathMap: pathMap,
    nameMap: nameMap
  };
  appendRoutes(router, routeMap, '', routes);
  return routeMap;
}

function registerEachHooks(router, hookType, userGuard) {
  var hooks = router.lifeCycleHooks[hookType];

  if (!hooks) {
    hooks = [];
    router.lifeCycleHooks[hookType] = hooks;
  }

  hooks.push(userGuard);
}

function isPageHook(vm) {
  return vm.$mpType === MP_TYPE_PAGE;
}

var RouterImpl = /*#__PURE__*/function () {
  function RouterImpl(options) {
    _classCallCheck(this, RouterImpl);

    _defineProperty(this, "proxyMode", void 0);

    _defineProperty(this, "proxyMethods", void 0);

    _defineProperty(this, "routes", void 0);

    _defineProperty(this, "indexRouteRule", void 0);

    _defineProperty(this, "lifeCycleHooks", {});

    _defineProperty(this, "$locked", false);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "routeMap", void 0);

    _defineProperty(this, "route", void 0);

    this.options = options;
    this.proxyMode = options.proxyMode || "hook"
    /* HOOK */
    ;
    this.proxyMethods = options.proxyMethods || DEFAULT_PROXY_METHODS;
    this.routes = parseRoutesFromPages(options.pageData);
    this.indexRouteRule = this.routes[0];
    this.routeMap = createRouteMap(this, this.routes);
  }

  _createClass(RouterImpl, [{
    key: "setupRouter",
    value: function setupRouter(app) {
      app.use(this);
    }
  }, {
    key: "push",
    value: function push(to) {
      return lockNavjump(to, this, "push"
      /* PUSH */
      );
    }
  }, {
    key: "replace",
    value: function replace(to) {
      return lockNavjump(to, this, "replace"
      /* REPLACE */
      );
    }
  }, {
    key: "replaceAll",
    value: function replaceAll(to) {
      return lockNavjump(to, this, "replaceAll"
      /* REPLACE_ALL */
      );
    }
  }, {
    key: "pushTab",
    value: function pushTab(to) {
      return lockNavjump(to, this, "pushTab"
      /* PUSH_TAB */
      );
    }
  }, {
    key: "back",
    value: function back() {
      var _uni;

      return (_uni = uni).navigateBack.apply(_uni, arguments);
    }
  }, {
    key: "beforeEach",
    value: function beforeEach(userGuard) {
      registerEachHooks(this, "be"
      /* BEFORE_EACH */
      , userGuard);
    }
  }, {
    key: "afterEach",
    value: function afterEach(userGuard) {
      registerEachHooks(this, "ae"
      /* AFTER_EACH */
      , userGuard);
    }
  }, {
    key: "install",
    value: function () {
      var _install = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(app) {
        var router, mixinOptions;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                router = this;
                StaticContext.app = app;
                StaticContext.router = router;
                Object.defineProperty(app.config.globalProperties, "$Router", {
                  get: function get() {
                    return router;
                  }
                });
                Object.defineProperty(app.config.globalProperties, "$Route", {
                  get: function get() {
                    return router.route;
                  }
                });

                if (router.proxyMode === "hook"
                /* HOOK */
                ) {
                  mixinOptions = {
                    beforeCreate: function beforeCreate() {
                      if (!isPageHook(this)) {
                        return;
                      }

                      var vm = this;
                      router.proxyMethods.forEach(function (hookName) {
                        var oriHookData = getOriHookData(vm, hookName);
                        var oldHooks = vm.$[hookName] || [];
                        var oldVal = Array.isArray(oldHooks) ? oldHooks : [oldHooks];
                        oriHookData.oldVal = oldVal;
                        oriHookData.wapper = wapperUniHooks(router, vm, hookName);
                        var newVal = [oriHookData.wapper];
                        var newValObj = newVal;

                        newVal.push = function () {
                          var _oriHookData$oldVal;

                          (_oriHookData$oldVal = oriHookData.oldVal).push.apply(_oriHookData$oldVal, arguments);

                          return newVal.length;
                        };

                        newVal.pop = function () {
                          return oriHookData.oldVal.pop();
                        };

                        newVal.shift = function () {
                          return oriHookData.oldVal.shift();
                        };

                        newVal.unshift = function () {
                          var _oriHookData$oldVal2;

                          (_oriHookData$oldVal2 = oriHookData.oldVal).unshift.apply(_oriHookData$oldVal2, arguments);

                          return newVal.length;
                        };

                        newValObj.splice = function () {
                          var _oriHookData$oldVal3;

                          return (_oriHookData$oldVal3 = oriHookData.oldVal).splice.apply(_oriHookData$oldVal3, arguments);
                        };

                        newVal.reverse = function () {
                          return oriHookData.oldVal.reverse();
                        };

                        newVal.sort = function () {
                          return oriHookData.oldVal.sort();
                        };

                        oriHookData.newVal = newVal;
                        Object.defineProperty(vm.$, hookName, {
                          get: function get() {
                            return oriHookData.newVal;
                          },
                          set: function set(val) {
                            if (val === oriHookData.newVal || val === oriHookData.wapper) {
                              return;
                            }

                            if (!val) {
                              oriHookData.oldVal = [];
                            } else if (Array.isArray(val)) {
                              if (val.indexOf(oriHookData.wapper) > -1) {
                                if (val.length > 1) {
                                  val.forEach(function (item) {
                                    if (item !== oriHookData.wapper) {
                                      oriHookData.oldVal.push(item);
                                    }
                                  });
                                }
                              } else {
                                oriHookData.oldVal = val;
                              }
                            } else {
                              oriHookData.oldVal = [val];
                            }
                          }
                        });
                      });
                    }
                  };
                } else if (router.proxyMode === "method"
                /* METHOD */
                ) {
                  mixinOptions = {
                    created: function created() {
                      if (!isPageHook(this)) {
                        return;
                      }

                      var vm = this;
                      var routerData = getRouterData(vm);
                      var oldMethods = {};
                      routerData.oldMethods = oldMethods;
                      router.proxyMethods.forEach(function (methodName) {
                        var oldMethod = vm[methodName];

                        if (!oldMethod) {
                          console.warn("\u6B64\u9875\u9762\u6CA1\u6709\u65B9\u6CD5:".concat(methodName));
                          return;
                        }

                        oldMethods[methodName] = oldMethod; //console.warn(`设置代理:${methodName}`)

                        vm[methodName] = function () {
                          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                            args[_key4] = arguments[_key4];
                          }

                          //console.warn(`执行代理:${methodName}`)
                          return wapperMethod(router, vm, methodName, args);
                        };
                      });
                    },
                    onInit: function onInit(query) {
                      if (!isPageHook(this)) {
                        return;
                      }

                      saveCurrRouteByCurrPage(router, this, query);
                    },
                    onLoad: function onLoad(query) {
                      if (!isPageHook(this)) {
                        return;
                      }

                      saveCurrRouteByCurrPage(router, this, query);
                    }
                  };
                }

                mixinOptions && app.mixin(mixinOptions);
                addNavInterceptor();

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function install(_x18) {
        return _install.apply(this, arguments);
      }

      return install;
    }()
  }]);

  return RouterImpl;
}();

function createRouter(options) {
  var router = new RouterImpl(options);
  return router;
}

export { UniLifecycleHooks, createRouter };
