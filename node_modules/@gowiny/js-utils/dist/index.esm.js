/**
  * gowiny-js-utils v1.0.7
  * https://gitee.com/gowiny/js-utils
  *
  * (c) 2022-present gowiny
  * @license MIT
  *
  * Date: 2022-03-24T10:27:26Z
  */
function isString(val) {
    return typeof (val) === "string";
}
function isBoolean(val) {
    return typeof (val) === 'boolean';
}
function isNumber(val) {
    return typeof (val) === 'number';
}
function isObject(val) {
    return typeof (val) === "object";
}
function isDate(value) {
    return value && value instanceof Date;
}
function isFunction(val) {
    return typeof (val) === 'function';
}
function isUndefined(val) {
    return typeof (val) === 'undefined';
}
/**
 * 判断是否为null,此函数undefined也表示为null
 * @param val -需要判断的对象
 * @returns
 */
function isNull(val) {
    return null === val || typeof (val) === 'undefined';
}
function isEmptyArray(list) {
    return !list || list.length == 0;
}
function type(val) {
    let result;
    if (val === null) {
        result = 'null';
    }
    else {
        const valType = typeof (val);
        if (valType === 'object') {
            if (Array.isArray(val)) {
                result = 'array';
            }
            else if (val instanceof Date) {
                result = 'date';
            }
            else {
                result = valType;
            }
        }
        else {
            result = valType;
        }
    }
    return result;
}
const NOT_ATOMIC_TYPES = ['object', 'array'];
function isAtomic(val) {
    const valType = type(val);
    return isAtomicType(valType);
}
function isAtomicType(valType) {
    return NOT_ATOMIC_TYPES.indexOf(valType) == -1;
}
const DEFAULT_COPY_CONF = { copyNull: true, copyUndefined: true };
function _depthCopyProps(conf, dest, srcData) {
    if (dest && srcData) {
        for (const key in srcData) {
            const srcVal = srcData[key];
            const srcValType = type(srcVal);
            if (isAtomicType(srcValType)) {
                if (srcValType === 'undefined') {
                    if (conf.copyUndefined !== false) {
                        dest[key] = srcVal;
                    }
                }
                else if (srcValType === 'null') {
                    if (conf.copyNull !== false) {
                        dest[key] = srcVal;
                    }
                }
                else {
                    dest[key] = srcVal;
                }
            }
            else {
                let destVal = dest[key];
                const destValType = type(destVal);
                if (destValType !== srcValType) {
                    destVal = srcValType === 'array' ? [] : {};
                    dest[key] = destVal;
                }
                _depthCopyProps(conf, destVal, srcVal);
            }
        }
    }
    return dest;
}
function _depthCopyPropsIfNotExists(dest, srcData) {
    if (dest && srcData) {
        for (const key in srcData) {
            let destVal = dest[key];
            const destValType = type(destVal);
            if ('undefined' != destValType && 'null' != destValType && isAtomicType(destValType)) { //如果目标属性不为null并且是原子属性，则跳过
                continue;
            }
            const srcVal = srcData[key];
            const srcValType = type(srcVal);
            if (isAtomicType(srcValType)) {
                if (srcValType === 'undefined' || 'null' === srcValType) { //源属性为null,不处理
                    continue;
                }
                else {
                    dest[key] = srcVal;
                }
            }
            else {
                if (destValType !== srcValType) {
                    destVal = srcValType === 'array' ? [] : {};
                    dest[key] = destVal;
                }
                _depthCopyPropsIfNotExists(destVal, srcVal);
            }
        }
    }
    return dest;
}
/**
 * 深度复制属性
 * @param dest -目标对象
 * @param srcList -需要复制的对象
 * @returns
 */
function depthCopyProps(dest, ...srcList) {
    return depthCopyPropsWithConf(DEFAULT_COPY_CONF, dest, ...srcList);
}
/**
 * 为目标对象设置默认值
 * @param dest -目标对象
 * @param srcList -默认值
 * @returns
 */
function setDefaultValues(dest, ...srcList) {
    if (dest && srcList && srcList.length > 0) {
        srcList.forEach(item => {
            _depthCopyPropsIfNotExists(dest, item);
        });
    }
    return dest;
}
const depthCopyPropsIf = setDefaultValues;
function depthCopyPropsWithConf(conf, dest, ...srcList) {
    if (dest && srcList && srcList.length > 0) {
        for (let i = 0; i < srcList.length; i++) {
            const item = srcList[i];
            _depthCopyProps(conf, dest, item);
        }
    }
    return dest;
}
/**
 * 克隆
 * @param data -克隆的对象
 * @returns
 */
function clone(data) {
    let result;
    const dataType = type(data);
    if (dataType === 'array') {
        result = depthCopyPropsWithConf(DEFAULT_COPY_CONF, [], data);
    }
    else if (dataType === 'object') {
        result = depthCopyPropsWithConf(DEFAULT_COPY_CONF, {}, data);
    }
    else {
        result = data;
    }
    return result;
}
/**
 * 序列执行
 * @param fns -需要执行的函数
 * @param target -目标对象
 * @param args -参数
 * @param assert -断言
 * @returns
 */
async function queueInvoke(fns, target, args, assert) {
    if (!fns) {
        return;
    }
    if (Array.isArray(fns)) {
        const len = fns.length;
        let result;
        for (let i = 0; i < len; i++) {
            const item = fns[i];
            result = await item.apply(target, args);
            if (assert && !(await assert(result))) {
                return result;
            }
        }
        return result;
    }
    else {
        return fns.apply(target, args);
    }
}
function invoke(fns, target, args) {
    if (!fns) {
        return;
    }
    let result;
    if (Array.isArray(fns)) {
        for (let i = 0; i < fns.length; i++) {
            const item = fns[i];
            result = item.apply(target, args);
        }
    }
    else {
        result = fns.apply(target, args);
    }
    return result;
}
const CLASS_INST_MAP = {};
function getClassDefaultInstance(clazz, factory, key = "_") {
    const clazzKey = clazz;
    let instMap = CLASS_INST_MAP[clazzKey];
    if (!instMap) {
        instMap = {};
        CLASS_INST_MAP[clazzKey] = instMap;
    }
    let inst = instMap[key];
    if (!inst) {
        inst = factory ? factory() : new clazz();
        instMap[key] = inst;
    }
    return inst;
}
function getClassDefaultValue(clazz, propertyKey, instFactory, instKey) {
    let inst = getClassDefaultInstance(clazz, instFactory, instKey);
    const result = inst[propertyKey];
    return result;
}

export { CLASS_INST_MAP, clone, depthCopyProps, depthCopyPropsIf, depthCopyPropsWithConf, getClassDefaultInstance, getClassDefaultValue, invoke, isAtomic, isAtomicType, isBoolean, isDate, isEmptyArray, isFunction, isNull, isNumber, isObject, isString, isUndefined, queueInvoke, setDefaultValues, type };
